# 第一章 引论

现代计算机系统由一个或多个处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他IO设备组成。计算机安装了一层软件，成为操作系统，它的任务是为用程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。

## 操作系统的两个状态

内核态和用户态，其本质就是CPU的两种状态。

- 内核态，又称管态或核心态。处理机运行操作系统的状态。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行及其能够运行的任何指令。
- 用户态，又称目态。处理机运行应用程序的状态。在用户态下，只是用了机器指令中的一个子集，特别的，会影响机器控制或可进行IO操作的指令，用户态完全禁止。

用户接口程序（shell或GUI）处于用户态程序中的最低层次，允许用户运行其他程序，诸如Web浏览器、电子邮件阅读器、音乐播放器等。

操作系统运行在裸机之上，为所有其他软件提供基础的运行环境。

**为什么要分状态**：在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果所有的程序都能使用这些指令，那么系统死机的概率将大大增加。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。

## 什么是操作系统

操作系统是一种运行在内核态的软件——尽管这个说法并不总是符合事实。部分原因是操作系统有两个基本上独立的任务，即为应用程序员（实际上是应用程序）提供一个资源集的清晰抽象，并管理这些资源，而不仅仅是一堆硬件。

- 作为扩展机器的操作系统
	- 隐藏硬件，呈献给程序（以及程序员）良好、清晰、优雅、一致的抽象。
- 作为资源管理者的操作系统
	- 在相互竞争的程序之间有序地控制对处理器、存储器以及其他IO接口设备的分配。

## 操作系统的历史
- 第一代：真空管和穿孔卡片
- 第二代：晶体管和批处理系统
- 第三代：集成电路和多道程序设计
- 第四代：个人计算机
- 第五代：移动计算机

## 操作系统分类
1. 大型机操作系统
1. 服务器操作系统
1. 多处理器操作系统
1. 个人计算机操作系统
1. 掌上计算机操作系统
1. 嵌入式操作系统
1. 传感器节点操作系统
1. 实时操作系统
1. 智能卡操作系统

## 系统启动

1 硬件系统加电

2 ROM BIOS自举程序  
- 2.1 硬件自检POST  
- 2.2 若软盘启动则执行2.4，若硬盘启动则执行2.5  
- 2.3 提示无启动盘  
- 2.4 将软盘物理第1扇区读入内存07C0:0000处，并将控制权转移到内存07C0:0000，从内存07C0:0000开始执行4  
- 2.5 将硬盘物理第1扇区读入内存07C0:0000处，并将控制权转移到内存07C0:0000，从内存07C0:0000开始执行3  

3 执行硬盘主引导程序，寻找到激活分区，将该分区首扇区读入07C0:0000，原硬盘主引导程序相应下移，从内存07C0:0000开始执行4  

4 执行引导程序(bootstrap)，装载相应盘上的OS内核并执行内核初始化程序等指令，从而将OS引导成功。

## 系统调用

### 什么是系统调用（理解着写吧）

　　在计算机中，系统调用（英语：system call），指运行在用户态的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。为了从操作系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。

**简单理解**：应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。

### TRAP指令
把用户态切换成内核态，并启用操作系统（书上这样写的，可能是调用操作系统的某些功能）。

### 原语

- 原语PRIMITE是由若干条指令所组成的一个指令序列，用来实现某个特定的操作功能。这个指令序列的执行是连续的，具有不可分割性，在执行时也不可间断，直至该指令序列执行结束
- 原子操作（atomic operation）：一个操作中的所有动作，要么全做，要么全不做
- 原语是os核心(由一组程序模块所组成的、完成os中基本功能)的一个组成部分，原语必须在内核态下执行，并且常驻内存

### 原语与系统调用的区别
原语具有不可中断性，它是通过在其执行过程中关闭中断实现的。原语往往是被系统进程所调用

## 并发 并行
### 并发（多线程）
当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。

### 并行（多核）
当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

### 区别
并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。

## 功能
> 找到了两种说法，如果问的话就混在一起答吧

### 一种说法
- 进程管理（Processing management）
- 内存管理（Memory management）
- 文件系统（File system）
- 网络通信（Networking）
- 安全机制（Security）
- 用户界面（User interface）
- 驱动程序（Device drivers）

### 另一种说法
操作系统的功能包括处理器管理、存储器管理、文件管理、设备管理。

## 操作系统的特点
> 我感觉看看有个印象就能答出来。
- 操作系统有四个特征：并发，共享，异步，虚拟。

### 并发
**并发是指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它应该具有处理和调度多个程序同时执行的能力。**

在这种多道程序环境下，一段时间内，宏观上有多个程序在同时运行，而每一时刻，单处理器环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。

### 共享
**共享是指系统中的资源（硬件资源和信息资源）可以被多个并发执行的程序共同使用，而不是被其中一个独占。资源共享有两种方式：互斥访问和同时访问。**

**并发和共享是操作系统的最基本特征，互为依存。并发执行的要求引出了资源的共享；而资源共享的管理又直接影响到程序的并发执行。**

### 异步
**异步在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底。而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。**
异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误。但是只要运行环境相同，操作系统必须保证多次运行程序，都获得相同的结果。

### 虚拟
**虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。**
采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。

## 操作系统体系结构

### 大内核
将操作系统的主要功能模块都作为一个紧密联系的整体（单一程序）运行在内核态，从而为应用提供高性能的系统服务。

**优点**：因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有性能优势。

**缺点**：调用任何一个你所需要的过程或许会非常高效，但上千个可以不受限制的彼此调用的过程常常导致系统笨拙且难于理解。并且，任何一个过程的崩溃都会连累整个系统。

### 微内核

将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在内核态执行的功能移到用户态执行，从而降低了内核的设计复杂性。而那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。

**优点**：微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。

**缺点**：微内核结构的最大问题是性能问题，因为需要频繁地在内核态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。

### 其他的体系结构
- 层次式系统
- 客户端-服务器模式
- 虚拟机

## 假脱机

> 我感觉简单看一遍懂了就行。

### 基本含义
SPOOLing 是 Simultaneous Peripheral（外设） Operation On-Line（联机） 的缩写，是关于慢速字符设备（慢速外设，比如打印机）如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。

在 PC 操作系统未采用“假脱机技术”之前，当低速的打印程序未结束时，字处理程序不能做其他的任何任务，包括和用户的交互。

### 组成
- **输入井和输出井**：输入井和输出井的存储区域是在磁盘上开辟出来的。输入输出井中的数据一般以文件的形式组织管理，这些文件称之为井文件。一个文件仅存放某一个进程的输入或输出数据，所有进程的数据输入或输出文件链接成为一个输入输出队列。 
- **输入缓冲区和输出缓冲区**：输入缓冲区和输出缓冲区的存储区域是在内存中开辟出来的。主要用于缓和CPU和磁盘之间速度不匹配的矛盾。输入缓冲区用于暂存有输入设备传送的数据，之后再传送到输入井；输出缓冲区同理。 
- **输入进程和输出进程**：输入进程也称为预输入进程，用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井。当CPU需要的时候，直接从输入井将数据读入内存。反之，输出的同理。 
- **井管理程序**：用于控制作业与磁盘井之间信息的交换。

### 特点
- **提高了I/O的速度**：对数据执行的I/O操作，已从对低速I/O设备执行的I/O操作演变为对磁盘缓冲区中数据的存取，如同脱机输入输出一样，提高了I/O速度，缓和了CPU和低速的I/Os设备之间速度的不匹配的矛盾。 
- **将独占设备改造成了共享设备**：因为在假脱机打印机系统中，实际上并没有为任何进程分配设备，而只是在磁盘缓冲区中为进程分配了一个空闲盘块和建立了一张I/O请求表。 
- **实现了虚拟设备功能**：宏观上，对于每一个进程而言，它们认为是自己独占了一个设备，即使实际上是多个进程在同时使用一台独占设备。也可以说，假脱机系统，实现了将独占设备变换为若干台对应的逻辑设备的功能。

### 实例

将一台独享打印机改造为可供多个用户共享的打印机，是应用SPOOLing技术的典型实例。

具体做法是：系统对于用户的打印输出，并不真正把打印机分配给该用户进程，而是先在输出井中申请一个空闲盘块区，并将要打印的数据送入其中；然后为用户申请并填写请求打印表，将该表挂到请求打印队列上。若打印机空闲，输出程序从请求打印队首取表，将要打印的数据从输出井传送到内存缓冲区，再进行打印，直到打印队列为空。
